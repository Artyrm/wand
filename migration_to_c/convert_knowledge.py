#!/usr/bin/env python

from os.path import basename

import json

KNOWLEDGE = 'test_knowledge.json'

OUTPUT = 'strokes.h'

PREFIX = 'stroke'

ACTION_TEMPLATE = 'ACTION_%i'

NORMAL_ACTION_LENGTH = 2


def stroke_const_name(key):
    return '{prefix}_{key}'.format(prefix=PREFIX.upper(), key=key.upper())


def format_define_to_c(name, value, comment=None):
    comment = ' // ' + comment if comment is not None else ''
    return '''#define {name} {value}{comment}
'''.format(name=name, value=value,
           comment=comment)


def format_action_to_c(value, empty_name):
    strokes = [stroke_const_name(stroke_name) for stroke_name in value]

    strokes += [empty_name] * (NORMAL_ACTION_LENGTH - len(strokes))

    return '    {%s}' % ', '.join(strokes)


def format_formated_strokes_to_c(value):
    data = ',\n'.join(['        {%s}' % ', '.join(['% 2.5f' % x for x in line])
                      for line in value])

    text = '''    {{\n{data}\n    }}'''
    return text.format(data=data)


def convert_knowledge(knowledge):
    empty_stroke_name = stroke_const_name('________')

    strokes = knowledge['strokes']

    names = knowledge['strokes_en_names']

    sequences = knowledge['sequences']['dictionary']

    sequences_names = knowledge['sequences_names']

    sequences_en_names = knowledge['sequences_en_names']

    init_stroke = knowledge['sequences']['init_stroke']

    h_text = ''

    h_text += ('/*\n * {filename}\n * autogenerated\n*/\n\n'
               .format(filename=basename(OUTPUT)))

    h_text += '#ifndef STROKES_H_\n#define STROKES_H_\n\n'

    h_text += format_define_to_c('SEGMENTATION', knowledge['segmentation'])

    h_text += format_define_to_c('STROKES_COUNT', len(strokes))

    h_text += format_define_to_c('SEQUENCES_COUNT',
                                 len(knowledge['sequences']['dictionary']))

    h_text += format_define_to_c('NORMAL_ACTION_LENGTH', NORMAL_ACTION_LENGTH)

    header = ''

    formated_strokes = []

    formated_actions = []

    for index, (key, value) in enumerate(strokes.items()):
        name = names[key] if key in names else key
        formated_strokes += [format_formated_strokes_to_c(value)]
        header += format_define_to_c(stroke_const_name(key), index, name)

    header += format_define_to_c(empty_stroke_name,
                                 index + 1,
                                 'used, if the seq is shorter then ' +
                                 'NORMAL_ACTION_LENGTH')

    header += '\n'

    header += format_define_to_c('INIT_STROKE', stroke_const_name(init_stroke))

    for index, (name, value) in enumerate(zip(sequences_names, sequences)):
        en_name = sequences_en_names[name]
        header += format_define_to_c(ACTION_TEMPLATE % index, index, en_name)
        formated_actions += [format_action_to_c(value, empty_stroke_name)]

    formated_actions = '''
const int_16t actions[SEQUENCES_COUNT][NORMAL_ACTION_LENGTH] = {{
{formated_actions}
}}'''.format(formated_actions=',\n'.join(formated_actions))

    formated_strokes = '''
const float_t strokes[STROKES_COUNT][SEGMENTATION][4] = {{
{formated_strokes}
}}'''.format(formated_strokes=',\n'.join(formated_strokes))

    h_text += ('{header}\n{formated_actions}\n{formated_strokes}'.
               format(header=header,
                      formated_actions=formated_actions,
                      formated_strokes=formated_strokes))

    h_text += '\n\n#endif\n'

    return h_text

if __name__ == '__main__':
    with open(KNOWLEDGE, 'r') as f:
        knowledge = json.load(f)

    h_text = convert_knowledge(knowledge)

    with open(OUTPUT, 'w') as f:
        f.write(h_text)
