Структура обработки данных
1. Данные с датчиков поступаю в виде строк следующего вида:
"ax ay az mx my mz gx gy gz\r\n",
где 'a' означает ускорение, 'm' - магнитное поле, 'g' - угловую скорость. Все числа - целые, знаковые.
Строки посылаются примерно каждые 20мс
2. Все управление процессами отдано Qt, в противном случае
GUI вообще не получал времени.
3. Реализовано это при помощи 2х QTimer'ов.
4. Каждые 20мс из последовательно порта забираются все данные, которые там есть, и склеиваются со буффером.
5. Если в буффере можно выдеить законченную строку (по символам '\r\n'), то она отделяется и отправляется на дальнейшую обработку. Если таких строк несколько - берется последняя из них. В буффере остается "хвост"
6. Если получившуюся строку можно разделить на 9 целых чисел, то к этому массиву дописывается временная отметка, и он заносится в список ожидания
7. Каждые 500мс из списка ожидания выбираются все имеющиеся там данные, временная метка преобразуется в значение времени, прошедшего между измерениями, и измерения одно за одним пропускаются через модуль IMU
8. На выходе получаеются Эйлеровы углы
9. Углы пересчитываются в единичный вектор напраления
10. Вектор направления и модуль угловой скорости передаются модулю Stroke. Он отсекает отдельные росчерки по пороговому значению угловой скорости, передает данные для отрисовки в реальном времени, а по завершении росчерка отдает его на распознавание.

Описание модулей:
IMU:
Является трансляцией с Си на Питон библиотеки от Ардуины.
В исходном коде был бесконечный цикл, который считывал данные с датчиков, обрабатывал их, ждал какое-то время, итд.
В нашем случае, Модуль стал полностью ведомым извне:
Реализуется это при помощи функции 'calc', которая принемает на вход значение времени, прошедшего с предудушего измерения, и вектор данных, который в дальнейшем является источником информации для функций 'read_accel', 'read_compass' и 'read_gyro'.
После этого присваивания однократно вызывается функция калибровки (первые N раз) или обработки данных.
Результат работы хранится в переменных pitch, yaw, roll.

Stroke:
В тот момент, когда значение угловой скорости превышает порог, происходит определение локальной системы координат: ось Z совпадает с глобальной, ось X - перпендикулярна оси Z и вектору палочки, ось Y - достраивается до правой тройки.
После этого формируется матрица перехода от глобальной системы координат к локальной.
Все дальнейшие значения указающего вектора, до конца выполнения росчерка приводятся в эту систем координат.
Координаты (3х мерные, лежат на сфере единичного радиуса) передаются внешнему виджету на отрисовку, а также сохраняются в список.
В момент завершения росчерка (скорость была ниже пороговой нужное число тактов), росчерк передается на обработку внешней функции (если была назначена), список точек сбрасывается, визуализация обнуляется.

unify_definition:
Для сравнения, росчерки приводятся к единому виду: вычисляется длина росчерка, которая делится на N равных частей, затем определяется где (между какими двумя точками исходной ломаной, и на каком отступе) должна располагаться каждая новая точка. В следствие этого получившиеся точки оказываются на +/- одинаковом расстоянии. На самом деле, конечно, расстояние между двумя соседними точками будет тем меньше l/N, чем острее углы исходной ломаной, попавшие между ними, но этот алгоритм дает вполне преемлемый результат.
Росчерк считается совпадающим с эталонным, если каждая из его точек лежит на расстоянии не больше, чем R от соответсвтующей точки эталонной кривой.
На этапе первоначального обучения, пока выборка эталоном мала, радиус задется единый для всех (и достаточно большой), после набора статистики будет использоваться индивидуальное значения для каждого.